scrape_website:
  description: >
    STEP 1: INVOKE THE TOOL
    You have access to a tool called "Playwright Style Extractor".
    You MUST call this tool with the URL: {url}

    Action: Use Action: Playwright Style Extractor
    Action Input: {url}

    STEP 2: WAIT FOR TOOL OUTPUT
    The tool will launch a browser, navigate to the URL, and return a dictionary with:
    - url: The URL that was scraped
    - html: Full HTML content from the rendered page
    - computed_styles: Browser-computed styles for key elements (header, nav, body, h1, button, a)
    - css_variables: CSS custom properties from :root (--variable-name: value)
    - assets: Logo and favicon URLs
    - success: true

    STEP 3: RETURN TOOL OUTPUT AS-IS
    Copy the EXACT output from the tool into your Final Answer.
    DO NOT modify, summarize, or reformat the tool output.
    DO NOT generate fake HTML, CSS, or colors.

    CRITICAL RULES:
    - If you did not call the tool, your answer is WRONG
    - If you generate fictional HTML/CSS, your answer is WRONG
    - If you write a "scraping report", your answer is WRONG
    - The ONLY acceptable answer is the raw dict from the Playwright Style Extractor tool

    Example of CORRECT workflow:
    Thought: I need to scrape {url} using the Playwright Style Extractor tool
    Action: Playwright Style Extractor
    Action Input: {url}
    Observation: {{"url": "{url}", "html": "<actual html>", "computed_styles": {{...}}, ...}}
    Thought: I have the tool output, I'll return it as my final answer
    Final Answer: {{"url": "{url}", "html": "<actual html>", "computed_styles": {{...}}, ...}}
  expected_output: >
    A raw Python dictionary (not a string, not prose) from the Playwright Style Extractor tool.

    MUST contain these keys:
    - url: string
    - html: string (actual HTML from browser)
    - computed_styles: dict (actual computed styles from browser)
    - css_variables: dict (actual CSS variables from browser)
    - assets: dict with logo and favicon URLs
    - success: boolean (true if scraping succeeded)

    Example format:
    {{
      "url": "https://example.com",
      "html": "<!DOCTYPE html><html>...",
      "computed_styles": {{"header": {{"backgroundColor": "rgb(22, 8, 34)", ...}}, ...}},
      "css_variables": {{"--primary-color": "#160822", ...}},
      "assets": {{"logo": "https://...", "favicon": "https://..."}},
      "success": true
    }}
  agent: web_scraper_agent

extract_styles:
  description: >
    Analyze the scraped HTML and CSS from the previous task to extract:

    Color Palette:
    - Primary brand color (most prominent, usually in headers/CTA buttons)
    - Secondary color (supporting color, often in subheadings)
    - Accent color (highlights, links, interactive elements)
    - Background color (page background, typically white or off-white)
    - Text color (body text, typically dark gray or black)

    Typography:
    - Heading font family (h1, h2, h3 elements)
    - Body font family (p, div, main text)
    - Heading size (base h1 size)
    - Body size (base paragraph size)
    - Line height (text readability setting)

    Layout:
    - Grid system (flexbox, CSS Grid, or column-based)
    - Spacing unit (base unit for margins/padding, usually 4px or 8px)
    - Border radius (roundness of elements)
    - Container max-width

    Use CSS specificity and frequency analysis to identify the most important values.
    Ignore inline styles that appear to be overrides or exceptions.
  expected_output: >
    A structured style analysis containing:
    1. ColorPalette with 5 colors (hex or rgb format)
    2. Typography settings with font families and sizes
    3. LayoutConfig with grid system and spacing
    4. Logo URL and favicon URL
    5. Confidence scores for each extracted value (0-100%)
  agent: style_analyst_agent
  context:
    - scrape_website

analyze_voice:
  description: >
    Analyze the website content from the scraping task to identify brand voice and tone:

    Tone Analysis:
    - Overall tone: professional, casual, energetic, sophisticated, friendly, technical
    - Can be multiple tones (e.g., "professional, energetic")

    Keywords:
    - Extract 5-10 key brand keywords that appear frequently
    - Focus on action words, industry terms, and brand-specific vocabulary

    Style:
    - Writing style: formal, conversational, technical, storytelling

    Personality:
    - Brand personality descriptor: innovative, traditional, bold, caring, authoritative

    Analyze:
    - Headlines and hero section copy
    - Call-to-action button text
    - Navigation and menu labels
    - Body content and descriptions
    - Microcopy and error messages (if present)

    Look for patterns in:
    - Sentence structure (short vs. long, simple vs. complex)
    - Word choice (technical jargon vs. plain language)
    - Use of first-person vs. third-person
    - Active vs. passive voice
    - Emotional language vs. factual statements
  expected_output: >
    A brand voice analysis containing:
    1. Tone (comma-separated string of tone descriptors)
    2. Keywords (list of 5-10 brand keywords)
    3. Style (writing style descriptor)
    4. Personality (optional personality descriptor)
    5. Confidence score (0-100%)
    6. Supporting evidence (quotes from the website)
  agent: voice_analyst_agent
  context:
    - scrape_website

compile_config:
  description: >
    Compile the style extraction and voice analysis into a complete EventStyleConfig
    JSON object that matches the Pydantic schema.

    Required fields:
    - event_id: Generate from the URL (e.g., "example-com" from "example.com")
    - event_name: Extract from page title or h1, or derive from domain
    - source_url: The original URL that was scraped
    - colors: ColorPalette object from style extraction
    - typography: Typography object from style extraction
    - brand_voice: BrandVoice object from voice analysis
    - layout: LayoutConfig object from style extraction (optional, has defaults)
    - logo_url: Logo URL from scraping (optional)
    - favicon_url: Favicon URL from scraping (optional)
    - scraped_at: Current ISO 8601 timestamp

    Validation requirements:
    - All color values must be valid CSS colors (hex, rgb, or hsl)
    - Font families should be complete with fallbacks (e.g., "Inter, sans-serif")
    - All required fields must be present
    - No extra fields beyond the schema

    If any required data is missing, use sensible defaults:
    - Colors: Use web-safe defaults (e.g., #000000 for text)
    - Fonts: Use system font stacks
    - Tone: Default to "professional"
  expected_output: >
    A complete, valid EventStyleConfig JSON object ready for export.
    The JSON must pass Pydantic validation without errors.
  agent: compiler_agent
  context:
    - scrape_website
    - extract_styles
    - analyze_voice
